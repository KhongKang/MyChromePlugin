
var viewTabId = 0;

var StorageAPI = chrome.storage.local;

var whiteListbloom, adsbloom, malwarebloom, tuplesbloom, bloom100k;//bloom filters
var bFilterFlag = 1, allowAdsFlag = false;//on/off flag of extension, ads allow flag
var userSetUnblockDomains = {};//unblock domains set by user.
var ancestorUrls = {};//ancestor hostnames of unblocked urls.
var blockedUrls = {};//blocked lists of mainframe domain 
var waitingAPIResult = new Set();
var enforcementMode = 0;
var downloadItem;

//Check domains if they are registerted in bf files.
function in100kList(host) {
    if (bloom100k == undefined) {
        //console.log("100kbloom is undefined!");
        return true;
    }
    if (bloom100k.test(host))
        return true;
    return false;
}

function inAds(host) {
    if (adsbloom == undefined) {
        //console.log("adsbloom is undefined!");
        return true;
    }
    if (adsbloom.test(host))
        return true;
    return false;
}

function inTuples(requestHost, refererHost) {
    if (tuplesbloom == undefined) {
        //console.log("tuplesbloom is undefined!");
        return true;
    }
    var tuplename = refererHost + ':' + requestHost;
    if (tuplesbloom.test(tuplename))
        return true;
    tuplename = requestHost + ':' + refererHost;
    if (tuplesbloom.test(tuplename))
        return true;
    return false;
}

function inWhiteList(host) {
    if (whiteListbloom == undefined) {
        //console.log("whiteListbloom is undefined!");
        return true;
    }
    if (whiteListbloom.test(host))
        return true;
    return false;
}

function checkMalwareSite(host) {

    if (malwarebloom == undefined) {
        //console.log("malwarebloom is undefined!");
        return true;
    }
    if (malwarebloom.test(host))
        return true;
    return false;
}

//get valid tabId
var toChromiumTabId = function (tabId) {
    if (typeof tabId === 'string') {
        tabId = parseInt(tabId, 10);
    }
    if (typeof tabId !== 'number' || isNaN(tabId) || tabId === -1) {
        return 0;
    }
    return tabId;
};

//For request to malware site, redirect to warning page
function replaceMalwarePage(tabId, url) {
    tabId = toChromiumTabId(tabId);
    if (tabId === 0) {
        return;
    }

    var targetURL = url;
    /*
    // extension pages
    if (/^[\w-]{2,}:/.test(targetURL) !== true) {
        targetURL = vAPI.getURL(targetURL);
    }
    */
    chrome.tabs.update(tabId, { url: targetURL }, function () {
        if (chrome.runtime.lastError) {
            /* noop */
        }
    });
};

function parseURL(n) {
    var t = {}, i = n.match(/^([^:]+):\/\/([^\/:]*)(?::([\d]+))?(?:(\/[^#]*)(?:#(.*))?)?$/i);
    return i ? (t.scheme = i[1].toLowerCase(), t.host = i[2].toLowerCase(), t.port = i[3], t.path = i[4] || "/", t.fragment = i[5], t) : t
}

//Save Blocked Urls for Each Tab
function saveBlockedDomain(ancestorUrl, requestUrl)
{
    if (!(ancestorUrl in blockedUrls))
    {
        blockedUrls[ancestorUrl] = new Set();
    }
    blockedUrls[ancestorUrl].add(requestUrl);
}
//Check if this domain must be blocked.
function isBlockedUrl(ancestorUrl, requestUrl)
{
    if (ancestorUrl in blockedUrls)
    {
        if (blockedUrls[ancestorUrl].has(requestUrl))
            return true;
    }
    return false;
}
//if user allow, delete the blocked url
function deleteBlockedUrl(ancestorUrl, requestUrl)
{
    if (ancestorUrl in blockedUrls)
    {
        if (blockedUrls[ancestorUrl].has(requestUrl))
            blockedUrls[ancestorUrl].delete(requestUrl);
    }
}

function addTuples(requestHostDomain, refererHostDomain) {
    if (tuplesbloom == undefined) {
        //console.log("tuplesbloom is undefined!");
        return;
    }
    var tuplename = requestHostDomain + ':' + refererHostDomain;
    tuplesbloom.add(tuplename);

    var save_array = [].slice.call(tuplesbloom.buckets);
    var json = JSON.stringify(save_array);

    StorageAPI.set({ "tuples": json });
    return;
}

function checkWaitingAPIResult(requestHostDomain, refererHostDomain) {
    var queryString = requestHostDomain + ":" + refererHostDomain;
    if (waitingAPIResult.has(queryString))
        return true;
    queryString = refererHostDomain + ":" + requestHostDomain;
    if (waitingAPIResult.has(queryString))
        return true;
    waitingAPIResult.add(queryString);
    return false;
}


function deleteWaitingAPIResult(requestHostDomain, refererHostDomain) {
    var str = requestHostDomain + ":" + refererHostDomain;
    waitingAPIResult.delete(str);
}

function handleAPIResult(requestHost, refererHost, tabId) {
    var requestHostDomain = getValidDomain(requestHost);
    var refererHostDomain = getValidDomain(refererHost);
    var ancestorOfthis = ancestorUrls[refererHost];
    if (ancestorUrls[refererHost] == undefined)
        ancestorOfthis = refererHost;
    else
        ancestorOfthis = ancestorUrls[refererHost];

    if (checkWaitingAPIResult(requestHostDomain, refererHostDomain))
        return;

    var onAPILoad = function () {

        deleteWaitingAPIResult(requestHostDomain, refererHostDomain);

        var APIResult = this.response;

        var res = APIResult.domainMatch;

        if (res)
        {
            addTuples(requestHostDomain, refererHostDomain);
            chrome.tabs.reload(tabId);
            return;
        }

        saveBlockedDomain(ancestorOfthis, requestHost);
        return;
    };
    var onAPIError = function () {
        //failed to fetch api data from backend
        deleteWaitingAPIResult(requestHostDomain, refererHostDomain);
        saveBlockedDomain(ancestorOfthis, requestHost);
        return;
    };

    //console.log("request url:" + requestHostDomain + " referer url:" + refererHostDomain + " begin API Query.");
    getMatchDataFromAPI(requestHostDomain, refererHostDomain, onAPILoad, onAPIError);
    return false;
}


function getMatchDataFromAPI(requestDomain, referDomain, onLoad, onError) {


    var format = "json";
    var url = "https://s73gzzhzve.execute-api.us-west-2.amazonaws.com/prod/whois/";
    var sendData = { request: requestDomain, referer: referDomain };

    var onResponseReceived = function () {

        this.onload = this.onerror = this.ontimeout = null;
        // xhr for local files gives status 0, but actually succeeds
        var status = this.status || 200;
        if (status < 200 || status >= 300) {
            return onError.call(this);
        }
        // consider an empty result to be an error
        if (this.response.byteLength == 0) {
            return onError.call(this);
        }
        return onLoad.call(this);
    };

    var onErrorReceived = function () {


        this.onload = this.onerror = this.ontimeout = null;
        return onError.call(this);
    };
    var xhrTimeout = 300000;
    // The function specified in jsonCallback will be called with a single argument representing the JSON object
    var xhr = new XMLHttpRequest();
    try {
        xhr.open('post', url, true);
        xhr.setRequestHeader('Content-Type', 'application/json');
        xhr.timeout = xhrTimeout;
        xhr.onload = onResponseReceived;
        xhr.onerror = onErrorReceived;
        xhr.ontimeout = onErrorReceived;
        xhr.responseType = format;
        xhr.send(JSON.stringify(sendData));
    } catch (e) {
        onErrorReceived.call(xhr);
    }
}

function registerAncestorUrl(requestHost, refererHost) {
    if (ancestorUrls[refererHost]) {
        ancestorUrls[requestHost] = ancestorUrls[refererHost];
    } else {
        ancestorUrls[requestHost] = refererHost;
    }
}

function getValidHostName(host) {
    if ((/^www\./).test(host)) {
        return host.substring(4);
    }
}

function getValidDomain(host) {
    return tld.getDomain(host);
}

function getDomainName(domain) {
    var arr = domain.split(".");
    return arr[0];
}

//Main blocking algorithm
function BlockingDomains(details) {

    //if user set off app, don't block.
    if (bFilterFlag == 0)
        return false;

    var requestUrl = details.url;
    var t = parseURL(requestUrl);
    var requestHost = t.host;

    var refererHost = '', refererUrl = '';

    //get refererUrl
    if (details.requestHeaders == undefined) {
        //console.log(requestUrl);
    }
    else {
        var e = details.requestHeaders.length;
        if (e != undefined) {
            for (var r = 0 ; r < e; ++r) {
                var name = details.requestHeaders[r].name;
                var value = details.requestHeaders[r].value;
                if (name.toLowerCase() == 'referer') {
                    refererUrl = value;
                    t = parseURL(refererUrl);
                    refererHost = t.host;
                    break;
                }
            }
        }
    }

    //console.log('Start request url: ' + requestHost + ' from referer url: ' + refererHost);

    //refererUrl, referHost : requestUrl, requestHost
    var requestHostDomain = getValidDomain(requestHost);

    var refererHostDomain = '';
    if (refererHost != "") 
        refererHostDomain = getValidDomain(refererHost);

    var tabId = details.tabId;

    //If it is request for mainframe(User browses to a site), check malware site
    if ((details.type == "main_frame") || (refererHost == "")) {
        if (checkMalwareSite(requestHost)) {
            //warn User;
            replaceMalwarePage(tabId, chrome.runtime.getURL('document-blocked.html'));
            return true;
        }
        if (checkMalwareSite(requestHostDomain)) {
            //warn User;
            replaceMalwarePage(tabId, chrome.runtime.getURL('document-blocked.html'));
            return true;
        }
        return false;
    }
    //Allow for static content type(stylesheets and images)
    if ((details.type == "stylesheet") || (details.type == "image"))
    {
        //console.log("Allow request for static content type: " + details.type);
        return false;
    }

    //Allow request to same domain, then allow
    if (requestHost == refererHost) {
        registerAncestorUrl(requestHost, refererHost);
        //console.log('request to same urls.');
        return false;
    }
    if (requestHostDomain == refererHostDomain) {
        registerAncestorUrl(requestHost, refererHost);
        //console.log('request to same urls.');
        return false;
    }

    var refererDomainName = '';
    var requestDomainName = '';

    if (refererHostDomain != null)
        refererDomainName = getDomainName(refererHostDomain);
    if (requestHostDomain != null)
        requestDomainName = getDomainName(requestHostDomain);

    if (requestDomainName == refererDomainName) {
        //console.log('request to same domain name: ' + requestDomainName);
        return false;
    }

    if (requestDomainName.endsWith("cdn") || requestDomainName.endsWith("static"))
    {
        //console.log('request to endswith cdn or static url: ' + requestDomainName);
        return false;
    }

    if (requestHost == ancestorUrls[refererHost]) {
        registerAncestorUrl(requestHost, refererHost);
        //console.log('request to same ancestor urls.');
        return false;
    }

    //if request a-different-domain, check if it is malware site.
    if (checkMalwareSite(requestHost) || checkMalwareSite(requestHostDomain)) {
        //warn User;
        replaceMalwarePage(tabId, chrome.runtime.getURL('document-blocked.html'));
        return true;
    }

    //Check a-different-domain in WhiteList
    if (inWhiteList(requestHostDomain) || inWhiteList(requestHost) || inWhiteList(requestDomainName)) {
        registerAncestorUrl(requestHost, refererHost);
        //console.log(requestHost + ' is in whitelist.');
        return false;
    }

    //Check a-different-domain:domain exists in tuples.bf
    if (inTuples(requestHostDomain, refererHostDomain)) {
        registerAncestorUrl(requestHost, refererHost);
        //console.log(requestHostDomain + ':' + refererHostDomain + ' is in tuples.');
        return false;
    }
    //Check a-different-domain:ancestor-domain exists in tuples.bf
    if (ancestorUrls[refererHost] != undefined)
    {
        var ancestorOfthis = ancestorUrls[refererHost];
        var ancestorDomain = getValidDomain(ancestorOfthis);
        if (inTuples(requestHostDomain, ancestorDomain)) {
            registerAncestorUrl(requestHost, refererHost);
            //console.log(requestHost + ': ancestor url: ' + ancestorOfthis + ' is in tuples.');
            return false;
        }
    }

    //Check if it is request to ads.
    if (inAds(requestHostDomain) || inAds(requestHost)) {

        var ancestorOfthis;
        if (ancestorUrls[refererHost] == undefined)
            ancestorOfthis = refererHost;
        else
            ancestorOfthis = ancestorUrls[refererHost];

        if (allowAdsFlag) {
            //If user allow ads domains
            //console.log(requestHost + ' is in adslist and you allowed ads.');
            registerAncestorUrl(requestHost, refererHost);

            if (isBlockedUrl(ancestorOfthis, requestHost)) {
                deleteBlockedUrl(ancestorOfthis, requestHost);
                //console.log("This url: " + requestHost + " was blocked before. unblocked by User now.");
                registerAncestorUrl(requestHost, refererHost);
            }
            return false;
        }
        //console.log("url:" + requestHost + " is ads and you didn\'t allow the ads.");
        //user doesn't allow ads domains.
        saveBlockedDomain(ancestorOfthis, requestHost);
        return true;
    }

    //If user allowed all urls for this page
    var ancestorOfthis;
    if (ancestorUrls[refererHost] == undefined)
        ancestorOfthis = refererHost;
    else
        ancestorOfthis = ancestorUrls[refererHost];

    if (isBlockedUrl(ancestorOfthis, requestHost)) {
        if (userSetUnblockDomains[ancestorOfthis] == 1) {
            //if user allow all domains for this page
            deleteBlockedUrl(ancestorOfthis, requestHost);
            //POST {“url”:”​ www.domain.com/uri​ ”, “supporting_domains” : [{“uri”: “​ http://domain1/uri​ ”, 
            //“whois” : {“registrantname” : “name”, “registrantemail”: “email”}, {}, {}}  ] }
            //console.log("This url: " + requestHost + " was blocked before. unblocked by User now.");
            registerAncestorUrl(requestHost, refererHost);
            return false;
        }
        //console.log("url: " + requestHost + " is blocked by saved data.");
        return true;
    }
    var ancestorDomain = getValidDomain(ancestorOfthis);
    if (enforcementMode == 0)
    {
        if ((in100kList(requestHostDomain)) || (in100kList(refererHostDomain)) || (in100kList(ancestorDomain)))
            return false;
    }
    //console.log("they will be handled by API result.")

    handleAPIResult(requestHost, refererHost, tabId);
    return true;//block
}

//readConfigFile
function readConfigFile() {

    var url = chrome.runtime.getURL('config.txt');
    var xhrTimeout = 300000;

    var onResponseReceived = function () {
        this.onload = this.onerror = this.ontimeout = null;
        // xhr for local files gives status 0, but actually succeeds
        var status = this.status || 200;
        if (status < 200 || status >= 300) {
            return;
        }
        // consider an empty result to be an error
        if (this.response.byteLength == 0) {
            return;
        }
        var configText = this.responseText;
        //console.log(configText);
        if (configText == 'mode=0')
            enforcementMode = 0;
        else
            enforcementMode = 1;
        //console.log("enforcementMode = " + enforcementMode);
        return;
    };

    var onErrorReceived = function () {
        return;
    };
    var xhr = new XMLHttpRequest();
    try {
        xhr.open('get', url, true);
        xhr.timeout = xhrTimeout;
        xhr.onload = onResponseReceived;
        xhr.onerror = onErrorReceived;
        xhr.ontimeout = onErrorReceived;
        xhr.responseType = 'text';
        xhr.send();
    } catch (e) {
        onErrorReceived.call(xhr);
    }
}

//Read BloomFilters.
function readBfFile(path, onLoad, onError) {

    var url = chrome.runtime.getURL(path);
    var xhrTimeout = 300000;

    var onResponseReceived = function () {
        this.onload = this.onerror = this.ontimeout = null;
        // xhr for local files gives status 0, but actually succeeds
        var status = this.status || 200;
        if (status < 200 || status >= 300) {
            return onError.call(this);
        }
        // consider an empty result to be an error
        if (this.response.byteLength == 0) {
            return onError.call(this);
        }
        // we never download anything else than plain text: discard if response
        // appears to be a HTML document: could happen when server serves
        // some kind of error page I suppose
        //       var array = JSON.parse(json);
        return onLoad.call(this);
    };

    var onErrorReceived = function () {
        this.onload = this.onerror = this.ontimeout = null;
        onError.call(this);
    };


    var xhr = new XMLHttpRequest();
    try {
        xhr.open('get', url, true);
        xhr.timeout = xhrTimeout;
        xhr.onload = onResponseReceived;
        xhr.onerror = onErrorReceived;
        xhr.ontimeout = onErrorReceived;
        xhr.responseType = 'json';
        xhr.send();
    } catch (e) {
        onErrorReceived.call(xhr);
    }
}

function read100kBfFile() {
    var on100kListLoad = function () {
        var array = this.response;

        bloom100k = new BloomFilter(array, 16);
        //console.log(bloom100k.test("msn.com"));
        //console.log(bloom100k.test("yahoo.co.jp"));
        //console.log(bloom100k.test("linkedin.com"));
        //console.log(bloom100k.test("general.com"));
    };
    var on100kListError = function () {

    };
    readBfFile('bf/100k.bf', on100kListLoad, on100kListError);
}

function readWhiteListBfFile() {
    var onWhiteListLoad = function () {
        var array = this.response;

        whiteListbloom = new BloomFilter(array, 16);

        var save_array = [].slice.call(whiteListbloom.buckets);
        json = JSON.stringify(save_array);

        StorageAPI.set({ "whiteList": json });

    };
    var onWhiteListError = function () {

    };
    StorageAPI.get({ "whiteList": {} }, function (json) {
        if (IsJsonString(json["whiteList"])) {
            saved_array = JSON.parse(json["whiteList"]);

            whiteListbloom = new BloomFilter(saved_array, 16);
        } else {
            readBfFile('bf/whitelist.bf', onWhiteListLoad, onWhiteListError);
        }
    });
}

function readAdsBfFile() {
    var onAdsLoad = function () {

        var array = this.response;

        adsbloom = new BloomFilter(array, 16);

        var save_array = [].slice.call(adsbloom.buckets);
        json = JSON.stringify(save_array);
        StorageAPI.set({ "ads": json });

    };
    var onAdsError = function () {
    };
    StorageAPI.get({ "ads": {} }, function (json) {
        if (IsJsonString(json["ads"])) {

            saved_array = JSON.parse(json["ads"]);

            adsbloom = new BloomFilter(saved_array, 16);

            //console.log(adsbloom.test("doubleclick.net"));
            //console.log(adsbloom.test("fallingfalcon.com"));
            //console.log(adsbloom.test("microsoftonline-p.com:office.com"));

        } else {
            readBfFile('bf/ads.bf', onAdsLoad, onAdsError);
        }
    });
}

function readMalwareBfFile() {
    var onMalwareLoad = function () {

        var array = this.response;

        malwarebloom = new BloomFilter(array, 16);

        var save_array = [].slice.call(malwarebloom.buckets);
        json = JSON.stringify(save_array);

        StorageAPI.set({ "malware": json });

    };
    var onMalwareError = function () {

    };
    StorageAPI.get({ "malware": {} }, function (json) {
        if (IsJsonString(json["malware"])) {
            saved_array = JSON.parse(json["malware"]);

            malwarebloom = new BloomFilter(saved_array, 16);
        } else {
            readBfFile('bf/malware.bf', onMalwareLoad, onMalwareError);
        }
    });
}


function readTuplesBfFile() {
    var json, saved_array;
    var onTuplesLoad = function () {

        var array = this.response;

        tuplesbloom = new BloomFilter(array, 16);

        var save_array = [].slice.call(tuplesbloom.buckets);
        json = JSON.stringify(save_array);

        StorageAPI.set({ "tuples": json });

        //console.log(tuplesbloom.test("urcmich.org:umich.edu"));
        //console.log(tuplesbloom.test("tikona4g.in:tikona.in"));
        //console.log(tuplesbloom.test("microsoftonline-p.com:office.com"));

    };
    var onTuplesError = function () {

    };
    StorageAPI.get({ "tuples": {} }, function (json) {
        if (IsJsonString(json["tuples"])) {
            saved_array = JSON.parse(json["tuples"]);

            tuplesbloom = new BloomFilter(saved_array, 16);

            //console.log(tuplesbloom.test("urcmich.org:umich.edu"));
            //console.log(tuplesbloom.test("tikona4g.in:tikona.in"));
            //console.log(tuplesbloom.test("microsoftonline-p.com:office.com"));

        } else {
            readBfFile('bf/tuples.bf', onTuplesLoad, onTuplesError);
        }
    });
}

function IsJsonString(str) {
    try {
        JSON.parse(str);
    } catch (e) {
        return false;
    }
    return true;
}

chrome.webRequest.onBeforeSendHeaders.addListener(
    function (details) {
        return { cancel: BlockingDomains(details) }
    },
    { urls: ["<all_urls>"] },
    ["blocking", "requestHeaders"]);

var filename;

chrome.downloads.onCreated.addListener(function (item) {

    //    console.log(item);
    downloadItem = item;
//    var json = JSON.stringify(item);
//    console.log("JSON of downloadItem :" + json);

    var fileInfo = {};

    var mime = "application/octet-stream";
    if (item.mime != '')
        mime = item.mime;

    filename = '';
    if (item.filename != '')
        filename = item.filename;
    else {
        var exp = /[\w][\w\-\.]+\.[\w]+$/i;
        var arr = exp.exec(item.url);
        if (arr != null)
        {
            if (arr.length == 1) {
                filename = arr[0];
            }
        }
    }

    if (mime == "application/octet-stream")
    {
        mime = defineMIMEofdownloadingFile(item);//get mime from file extension
        downloadItem.mime = mime;
    }
    /*
    if ((mime == 'application/zip') || (mime == 'application/x-zip-compressed'))
    {
        if (filename != '')
            console.log("Downloading filename is: " + filename);
        else
            console.log("Didn't get Downloading filename");

        handleZipFiles(item);
    }/*
    else if (mime == 'application/rar')
    {
        handleRarFiles(item);
    }
    else
    {*/
    //        if (mime == "application/octet-stream")

    readAndHandleFile(downloadItem, item, fileInfo, mime);
    /*
    if ((fileInfo.mimeType != '') && (fileInfo.mimeType != "application/octet-stream") && (fileInfo.mimeType != undefined))
    {
        mime = fileInfo.mimeType;//get mime from magic header
        downloadItem.mime = mime;
    }*/
//    }
//    console.log("MIME type of downloading file is " + mime);
//    console.log("Downloading URL is: " + item.url);
});



var zipFs = new zip.fs.FS();
var zipDirectoryName = '';
var index = 0;

function onerror(message) {
    console.error(message);
}

function zipImportedZip(url, callback) {
    zipDirectoryName = "import" + index;
    index++;
    var directory = zipFs.root.addDirectory(zipDirectoryName);
    directory.importHttpContent(url, false, function () {
        zipFs.exportBlob(callback);
    }, onerror);
}

function getContentEntries(downloadItem, blob) {
    zipFs.importBlob(blob, function () {
        var directory = zipFs.root.getChildByName(zipDirectoryName);
        var text = '';
        getzippedFileNamesRecursively(directory);
        downloadItem.zipcontents = text;
        var json = JSON.stringify(downloadItem);
        console.log(json);
        //        console.log(text);

        function getzippedFileNamesRecursively(entry) {
            if (entry.children.length == 0) {
                text += entry.name + "  ";
            } else {
                for (var i = 0; i < entry.children.length; i++) {
                    getzippedFileNamesRecursively(entry.children[i]);
                }
            }
        }
    }, onerror);
}

function handleZipFiles(downloadItem, item) {
    if ((item.fileSize != -1) && (item.fileSize < 100000000))
    {
        zipDirectoryName = item.url;
        zipImportedZip(item.url, function (zippedBlob) {
            getContentEntries(downloadItem, zippedBlob);
        });

    } else {
        var json = JSON.stringify(downloadItem);
        console.log(json);

        var t = parseURL(item.url);
        var zipdomain = getValidDomain(t.host);

        for (var i = 0; i < downloadwhitelist.length; i ++)
        {
            if (zipdomain == downloadwhitelist[i])
                return;
        }
        //console.log("This downloading is canceled by extension!")
        chrome.downloads.cancel(item.id, function () { });
    }
}

/*
var count = 0;
var entries;
var tablearr = [];

function callback(error, entry) {

    if (error) {
        console.log(error);
    } else {
        count++;

        tablearr.push({
            "name": entries[count - 1].name,
            "type": entry.type,
            "size": entry.size,
        });

        if (count == entries.length) {
            console.log(tablearr);
        }
    }
}

function handleRarFiles(item) {
    if ((item.fileSize != -1) && (item.fileSize < 100000000)) {

        RarArchive(item.url, function (err) {
            self = this;
            if (err) {
                console.log(err);
                return;
            }
            this.entries.forEach(function (file) {
                self.get(file, callback);
            });

            entries = this.entries;
        });

    } else {
        var t = parseURL(item.url);
        var rardomain = getValidDomain(t.host);

        for (var i = 0; i < downloadwhitelist.length; i++) {
            if (rardomains == downloadwhitelist[i])
                return;
        }
        console.log("This downloading is canceled by extension!")
        chrome.downloads.cancel(item.id, function () { });
    }
}
*/
function readDownloadFile(item, onLoad, onError) {
    var format = "arraybuffer";
    var url = item.url;

    var onResponseReceived = function () {

        this.onload = this.onerror = this.ontimeout = null;
        // xhr for local files gives status 0, but actually succeeds
        var status = this.status || 200;
        if (status < 200 || status >= 300) {
            return onError.call(this);
        }
        // consider an empty result to be an error
        if (this.response.byteLength == 0) {
            return onError.call(this);
        }
        return onLoad.call(this);
    };

    var onErrorReceived = function () {

        this.onload = this.onerror = this.ontimeout = null;
        return onError.call(this);
    };
    var xhrTimeout = 30000;
    // The function specified in jsonCallback will be called with a single argument representing the JSON object
    var xhr = new XMLHttpRequest();
    try {
        xhr.open('get', url, true);
        xhr.setRequestHeader('Range', "bytes=0-255");
        xhr.timeout = xhrTimeout;
        xhr.onload = onResponseReceived;
        xhr.onerror = onErrorReceived;
        xhr.ontimeout = onErrorReceived;
        xhr.responseType = format;
        xhr.send();
    } catch (e) {
        onErrorReceived.call(xhr);
    }
}

function defineMIMEofdownloadingFile(item) {
    var exp = /[\w-]+.\w+$/i;
    var filename = (exp.exec(item.url))[0];
    return zip.getMimeType(filename);
}

function readAndHandleFile(downloadItem, item, fileInfo, mime) {
    var onLoad = function () {
        var i;
        var buf = new Uint8Array(this.response);
        var a = this.getResponseHeader("Content-Location");
        var b = this.getResponseHeader("Content-Disposition");
        //console.log("Content-Location of Response Header: " + this.getResponseHeader("Content-Location"));
        console.log("Content-Disposition of Response Header: " + this.getResponseHeader("Content-Disposition"));

        if ((filename == '') && (b != null)) {
            var fileExp1 = /filename="[\s\S]+"/i;
            var arr = fileExp1.exec(b);
            if (arr.length >= 1) {
                var filename1 = arr[0];
                var arr1 = filename1.split('"');
                filename = arr1[1];
            }
        }
        downloadItem.filename = filename;
        /*
        if (filename != '')
            console.log("Downloading filename is: " + filename);
        else
            console.log("Didn't get Downloading filename");
        */
        if ((mime == 'application/zip') || (mime == 'application/x-zip-compressed')) {
            handleZipFiles(downloadItem, item);
        } else {
            for (i = signatures.length - 1; i >= 0; i--) {
                if (bufferIsEqual(buf.slice(0, signatures[i].byteSeq.length), signatures[i].byteSeq)) {
                    fileInfo.extension = signatures[i].extension;
                    fileInfo.description = signatures[i].description || '';
                    if (signatures[i].mimeType != undefined)
                        fileInfo.mimeType = signatures[i].mimeType.mime || 'application/octet-stream';
                    else
                        fileInfo.mimeType = '';

                    //console.log(fileInfo);
                    if ((fileInfo.mimeType != '') && (fileInfo.mimeType != "application/octet-stream") && (fileInfo.mimeType != undefined)) {
                        mime = fileInfo.mimeType;//get mime from magic header
                        downloadItem.mime = mime;
                    }
                    if (fileInfo.mimeType == 'application/zip') {
                        handleZipFiles(downloadItem, item);
                    }
                    else
                    {
                        var json = JSON.stringify(downloadItem);
                        console.log(json);
                    }
                    return;
                }
            }
            var json = JSON.stringify(downloadItem);
            console.log(json);
        }
        return;
    };
    var onError = function () {
        return;
    };
    readDownloadFile(item, onLoad, onError);
    return;
}

var bufferIsEqual = function (buf1, buf2) {
    var i;
    if (buf1.length != buf2.length)
        return false;
    for (i = buf1.length - 1; i >= 0; i--)
        if (buf1[i] != buf2[i])
            return false;
    return true;
}

//start background process.
readConfigFile();
read100kBfFile();
readWhiteListBfFile();
readAdsBfFile();
readMalwareBfFile();
readTuplesBfFile();

//updateBfFiles();
/*
var bfRequestTimeInterval = 3600 * 1000;//1 hour
setInterval(updateBfFiles, bfRequestTimeInterval);
*/

var hashofwhitelist, hashofads, hashofmalware, hashoftuples;

function updateBfFiles() {
    calcSha256Value();
    queryServerForUpdate();
}

function queryServerForUpdate() {
    AWS.config.update({ accessKeyId: 'AKIAJ2OWIJK45IGBG5JQ', secretAccessKey: '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' });
    AWS.config.region = 'us-east-1';
    /*
    new AWS.S3().listObjects({ Bucket: 'cloudxec-chrome' }, function (error, data) {
        if (error) {
            console.log(error); // an error occurred
        } else {
            console.log(data); // request succeeded
        }
    });
    */
    
    var s3 = new AWS.S3();
    var params = {
        Bucket: 'cloudxec-chrome', /* required */
        Key: 'hash', /* required */
        ResponseContentType: 'json',
    };
    s3.getObject(params, function (err, data) {
        if (err) console.log(err, err.stack); // an error occurred
        else {
            //console.log(data);           // successful response

            if (IsJsonString(data.Body)) {
                var object = JSON.parse(data.Body);
                //console.log(object);

                if ((object.tuples != undefined) && (object.tuples != hashoftuples))
                {
                    hashoftuples = object.tuples;
                    updateTuples();
                }
                if ((object.whiteList != undefined) && (object.whiteList != hashofwhitelist))
                    updateWhitelist();
                if ((object.malware != undefined) && (object.malware != hashofmalware))
                    updateMalware();
                if ((object.ads != undefined) && (object.ads != hashofads))
                    updateAds();
            }
        }
    });
}

function updateWhitelist() {
    var s3 = new AWS.S3();
    var params = {
        Bucket: 'cloudxec-chrome', /* required */
        Key: 'whitelist.bf', /* required */
        ResponseContentType: 'json',
    };
    s3.getObject(params, function (err, data) {
        if (err) console.log(err, err.stack); // an error occurred
        else {

            var array = data.Body;
            var updated_array = JSON.parse(array);

            whiteListbloom = new BloomFilter(updated_array, 16);

            //console.log(whiteListbloom.test("aads1.net"));
            //console.log(whiteListbloom.test("addthis.com"));
            //console.log(whiteListbloom.test("microsoftonline-p.com:office.com"));

            var save_array = [].slice.call(whiteListbloom.buckets);
            json = JSON.stringify(save_array);

            StorageAPI.set({ "whiteList": json });
        }
    });
}

function updateTuples() {
    var s3 = new AWS.S3();
    var params = {
        Bucket: 'cloudxec-chrome', /* required */
        Key: 'tuples.bf', /* required */
        ResponseContentType: 'json',
    };
    s3.getObject(params, function (err, data) {
        if (err) console.log(err, err.stack); // an error occurred
        else {
            var array = data.Body;
            var updated_array = JSON.parse(array);

            tuplesbloom = new BloomFilter(updated_array, 16);

            var save_array = [].slice.call(tuplesbloom.buckets);
            json = JSON.stringify(save_array);

            //console.log(tuplesbloom.test("urcmich.org:umich.edu"));
            //console.log(tuplesbloom.test("tikona4g.in:tikona.in"));
            //console.log(tuplesbloom.test("microsoftonline-p.com:office.com"));

            StorageAPI.set({ "tuples": json });
        }
    });
}

function updateMalware() {
    var s3 = new AWS.S3();
    var params = {
        Bucket: 'cloudxec-chrome', /* required */
        Key: 'malware.bf', /* required */
        ResponseContentType: 'json',
    };
    s3.getObject(params, function (err, data) {
        if (err) console.log(err, err.stack); // an error occurred
        else {

            var array = data.Body;
            var updated_array = JSON.parse(array);

            malwarebloom = new BloomFilter(updated_array, 16);

            //console.log(malwarebloom.test("ranger.leoramaekers.nl"));
            //console.log(malwarebloom.test("notes.moonclub.ro"));
            //console.log(malwarebloom.test("canalshopping.com"));

            var save_array = [].slice.call(malwarebloom.buckets);
            json = JSON.stringify(save_array);

            StorageAPI.set({ "malware": json });
        }
    });
}

function updateAds() {
    var s3 = new AWS.S3();
    var params = {
        Bucket: 'cloudxec-chrome', /* required */
        Key: 'ads.bf', /* required */
        ResponseContentType: 'json',
    };
    s3.getObject(params, function (err, data) {
        if (err) console.log(err, err.stack); // an error occurred
        else {

            var array = data.Body;
            var updated_array = JSON.parse(array);

            adsbloom = new BloomFilter(updated_array, 16);

            //console.log(adsbloom.test("doubleclick.net"));
            //console.log(adsbloom.test("fallingfalcon.com"));
            //console.log(adsbloom.test("microsoftonline-p.com:office.com"));

            var save_array = [].slice.call(adsbloom.buckets);
            json = JSON.stringify(save_array);

            StorageAPI.set({ "ads": json });
        }
    });
}

function calcSha256Value() {

    var ads_array = [].slice.call(adsbloom.buckets);
    var ads_json = JSON.stringify(ads_array);
    hashofads = sha256_digest(ads_json);
    //console.log(hashofads);

    var whitelist_array = [].slice.call(whiteListbloom.buckets);
    var whitelist_json = JSON.stringify(whitelist_array);
    hashofwhitelist = sha256_digest(whitelist_json);
    //console.log(hashofwhitelist);


    var malware_array = [].slice.call(malwarebloom.buckets);
    var malware_json = JSON.stringify(malware_array);
    hashofmalware = sha256_digest(malware_json);
    //console.log(hashofmalware);

    if (hashoftuples == undefined)
    {
        var tuples_array = [].slice.call(tuplesbloom.buckets);
        var tuples_json = JSON.stringify(tuples_array);
        hashoftuples = sha256_digest(tuples_json);
        //console.log(hashoftuples);
    }
}

var application = 'com.convert.bat';
var port = chrome.runtime.connectNative(application);
var notificationId = "";

chrome.downloads.onChanged.addListener(function (changedItem) {

    if ((changedItem.state != undefined) &&
        (changedItem.state.current == "complete"))
    {
        console.log(changedItem);
        chrome.downloads.search({ id: changedItem.id }, function (items) {
            resultItem = items[0];
            console.log(resultItem);

            if (resultItem.exists != true)
                return;
            console.log(port);
            if (port == null)
                port = chrome.runtime.connectNative(application);

            var filename = resultItem.filename;
            if ((filename != null) && (filename != undefined))
            {
                var parts = resultItem.filename.split('.');
                var ext = parts[parts.length - 1];
                if ((ext == "doc") || (ext == "xls")) {

                    let bin = "", nme = "";
                    let name = parts[0].length ? parts[0].split('\\').pop() : "";
                    console.log(name);
                    switch (ext) {
                        case "doc": bin = "wordconv"; nme = "-nme"; break;
                        case "xls": bin = "excelcnv"; break;
                    }
                    var msg = {};
                    port.onMessage.addListener(handleMsg);

                    port.onDisconnect.addListener(function (e) {
                        log('unexpected disconnect');

                        port = chrome.runtime.connectNative(application);
                    });

                    function handleMsg(msg) {
                        if (msg == "OK")
                            chrome.notifications.create("convertOfficeNotification", {
                                type: "basic",
                                iconUrl: "../img/icon48.png",
                                title: 'Notification',
                                message: 'Your downloaded file <' + name + "." + ext + "> is converted to <" + name + "." + ext + "x>"
                            })
                        log(msg);

                    }
                    function log(msg) {
                        console.log(msg);
                    }
                    msg.bin = bin;
                    msg.nme = nme;
                    msg.filename = name;
                    msg.ext = ext;
                    msg.count = 0;
                    msg.fullpath = resultItem.filename.replace(/\\/g, '\\\\');
                    console.log(msg);

                    if (port != null) {
                        log('port.postMessage');
                        port.postMessage(msg);
                    } else {
                        log('chrome.runtime.sendNativeMessage');
                        chrome.runtime.sendNativeMessage(application, msg, log);
                    }
                }
            }
        });
    }
});
